{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf360
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww9000\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\ql\qnatural\pardirnatural

\f0\fs24 \cf0 '''\
class LTvsLT:  \
    \
    def createMatrix(self,LD,LT1,LT2):\
        \
	x=len(LT1.getArrayLatentTopics())\
        y=len(LT2.getArrayLatentTopics())\
        \
	matirx = zeros((x,y))\
        \
	for data in LD:\
            i=LT1.getMostImportantLatentTopic(data.getId())\
            j=LT2.getMostImportantLatentTopic(data.getId())\
            matirx[i.getId(),j.getId()]=matirx[i.getId(),j.getId()]+1\
        \
	return matirx\
\
    def imagePrint(self,escala,path,M,dimx,dimy,G,B):\
        Mt = self.escalarM(M)\
        size = (dimx,dimy)\
        im = Image.new('RGB',(escala*size[1],escala*size[0]))\
        pix = im.load()\
        for i in range(size[0]):\
            for j in range(size[1]):\
                    for k in range(escala):\
                            for l in range(escala):\
                                    pix[(j*escala)+l,(i*escala)+k]  = (int(Mt[i,j]),G,B)\
        im.save(path)\
        \
    def escalarM(self,M):\
        Mt = M.copy()\
        maxi = 0\
        for i in range(M.shape[0]):\
                for j in range(M.shape[1]):\
                        if M[i,j]>maxi:\
                                maxi = M[i,j]\
        for i in range(M.shape[0]):\
                for j in range(M.shape[1]):\
                        Mt[i,j]=M[i,j]*255/maxi\
        return Mt\
    \
\
    #FALTA D QUI EN ADELANTE\
    #def createLTvsLT(self,path,LD,LT1,LT2):\
    def LTSelection(self,LD,LT1,LT2,MIN):\
        MF=self.createLTvsLT(LD,LT1,LT2)\
        SLT1=set()\
        SLT2=set()\
        SLT=[]\
        for i in xrange(MF.shape[0]):\
            for j in xrange(MF.shape[1]):\
                if MF[i,j]>=MIN:\
                  SLT1.add(LT1.ArrayLatentTopics[i].id)\
                  SLT2.add(LT2.ArrayLatentTopics[j].id)\
                  SLT.append((LT1.ArrayLatentTopics[i].id,LT2.ArrayLatentTopics[j].id))\
        return SLT,SLT1,SLT2\
    \
    def LTreduction(self,LD,LT1,LT2,MIN):\
        ST1,ST2self.LTSelection(LD,LT1,LT2)\
        LT1.ArrayLatentTopics=[]\
        k=0\
        for i in xrange(len(SLT1)):\
            i.id=k\
            k=k+1\
            LT1.ArrayLatentTopics.append(i)\
            \
        k=0\
        for i in xrange(len(SLT2)):\
            i.id=k\
            k=k+1\
            LT2.ArrayLatentTopics.append(i)\
        \
\
        MF=self.createLTvsLT(LD,LT1,LT2)\
        return LT1,LT2,MF\
        \
    def createimgDictionary(self,LD):\
        x=xrange(len(LD))\
        return  dict(zip(LD, x))\
\
class ImageMatrix:\
    \
    def imagePrint(self,escala,path,M,dimx,dimy,G,B):\
        Mt = self.escalarM(M)\
        size = (dimx,dimy)\
        im = Image.new('RGB',(escala*size[1],escala*size[0]))\
        pix = im.load()\
        for i in range(size[0]):\
            for j in range(size[1]):\
                    for k in range(escala):\
                            for l in range(escala):\
                                    pix[(j*escala)+l,(i*escala)+k]  = (int(Mt[i,j]),G,B)\
        im.save(path)\
        \
    def escalarM(self,M):\
        Mt = M.copy()\
        maxi = 0\
        for i in range(M.shape[0]):\
                for j in range(M.shape[1]):\
                        if M[i,j]>maxi:\
                                maxi = M[i,j]\
        for i in range(M.shape[0]):\
                for j in range(M.shape[1]):\
                        Mt[i,j]=M[i,j]*255/maxi\
        return Mt\
        \
'''\
}